// Generated by CoffeeScript 1.9.1
'use strict';
var SourceMapConsumer, SourceMapGenerator, SourceNode, anysort, basename, common, concat, debug, extractOrder, flatten, generate, mapOptimizerChain, optimize, ref, sort, sortByConfig, waterfall,
  indexOf = [].indexOf || function(item) { for (var i = 0, l = this.length; i < l; i++) { if (i in this && this[i] === item) return i; } return -1; };

debug = require('debug')('brunch:generate');

basename = require('path').basename;

waterfall = require('async-waterfall');

anysort = require('anysort');

common = require('./common');

ref = require('source-map'), SourceMapConsumer = ref.SourceMapConsumer, SourceMapGenerator = ref.SourceMapGenerator, SourceNode = ref.SourceNode;

sortByConfig = function(files, config) {
  var criteria, ref1, ref2, ref3, ref4, ref5, ref6;
  if (toString.call(config) === '[object Object]') {
    criteria = [
      (ref1 = config.before) != null ? ref1 : [], (ref2 = config.after) != null ? ref2 : [], (ref3 = config.joinToValue) != null ? ref3 : [], (ref4 = config.bower) != null ? ref4 : [], (ref5 = config.component) != null ? ref5 : [], (ref6 = config.vendorConvention) != null ? ref6 : function() {
        return false;
      }
    ];
    return anysort.grouped(files, criteria, [0, 2, 3, 4, 5, 6, 1]);
  } else {
    return files;
  }
};

flatten = function(array) {
  return array.reduce(function(acc, elem) {
    return acc.concat(Array.isArray(elem) ? flatten(elem) : [elem]);
  }, []);
};

extractOrder = function(files, config) {
  var after, before, bower, component, conventions, orders, packageInfo, ref1, types, vendorConvention;
  types = files.map(function(file) {
    return file.type + 's';
  });
  orders = Object.keys(config.files).filter(function(key) {
    return indexOf.call(types, key) >= 0;
  }).map(function(key) {
    var ref1;
    return (ref1 = config.files[key].order) != null ? ref1 : {};
  });
  before = flatten(orders.map(function(type) {
    var ref1;
    return (ref1 = type.before) != null ? ref1 : [];
  }));
  after = flatten(orders.map(function(type) {
    var ref1;
    return (ref1 = type.after) != null ? ref1 : [];
  }));
  ref1 = config._normalized, conventions = ref1.conventions, packageInfo = ref1.packageInfo;
  vendorConvention = conventions.vendor;
  bower = packageInfo.bower.order;
  component = packageInfo.component.order;
  return {
    before: before,
    after: after,
    vendorConvention: vendorConvention,
    bower: bower,
    component: component
  };
};

sort = function(files, config, joinToValue) {
  var indexes, order, paths;
  paths = files.map(function(file) {
    return file.path;
  });
  indexes = Object.create(null);
  files.forEach(function(file, index) {
    return indexes[file.path] = file;
  });
  order = extractOrder(files, config);
  if (Array.isArray(joinToValue)) {
    order.joinToValue = joinToValue;
  }
  return sortByConfig(paths, order).map(function(path) {
    return indexes[path];
  });
};

concat = function(files, path, type, definition, aliases) {
  var root;
  root = new SourceNode();
  debug("Concatenating " + (files.map(function(_) {
    return _.path;
  }).join(', ')) + " to " + path);
  files.forEach(function(file) {
    var data;
    root.add(file.node);
    data = file.node.isIdentity ? file.data : file.source;
    if (type === 'javascript' && ';' !== data.trim().substr(-1)) {
      root.add(';');
    }
    return root.setSourceContent(file.node.source, data);
  });
  if (type === 'javascript') {
    root.prepend(definition(path, root.sourceContents));
  }
  if (aliases != null) {
    aliases.forEach(function(alias) {
      var key;
      key = Object.keys(alias)[0];
      return root.add("require.alias('" + key + "', '" + alias[key] + "');");
    });
  }
  return root.toStringWithSourceMap({
    file: path
  });
};

mapOptimizerChain = function(optimizer) {
  return function(params, next) {
    var code, data, map, optimizerArgs, path, sourceFiles;
    data = params.data, code = params.code, map = params.map, path = params.path, sourceFiles = params.sourceFiles;
    debug("Optimizing '" + path + "' with '" + optimizer.constructor.name + "'");
    optimizerArgs = optimizer.optimize.length === 2 ? [params] : [data, path];
    optimizerArgs.push(function(error, optimized) {
      var newMap, optimizedCode, optimizedMap;
      if (error != null) {
        return next(error);
      }
      if (toString.call(optimized) === '[object Object]') {
        optimizedCode = optimized.data;
        optimizedMap = optimized.map;
      } else {
        optimizedCode = optimized;
      }
      if (optimizedMap != null) {
        newMap = SourceMapGenerator.fromSourceMap(new SourceMapConsumer(optimizedMap));
        if (newMap._sourcesContents == null) {
          newMap._sourcesContents = {};
        }
        sourceFiles.forEach(function(arg) {
          var path, source;
          path = arg.path, source = arg.source;
          return newMap._sourcesContents["$" + path] = source;
        });
      } else {
        newMap = map;
      }
      return next(error, {
        data: optimizedCode,
        code: optimizedCode,
        map: newMap,
        path: path,
        sourceFiles: sourceFiles
      });
    });
    return optimizer.optimize.apply(optimizer, optimizerArgs);
  };
};

optimize = function(data, map, path, optimizers, sourceFiles, callback) {
  var first, initial;
  initial = {
    data: data,
    code: data,
    map: map,
    path: path,
    sourceFiles: sourceFiles
  };
  first = function(next) {
    return next(null, initial);
  };
  return waterfall([first].concat(optimizers.map(mapOptimizerChain)), callback);
};

generate = function(path, sourceFiles, config, optimizers, callback) {
  var code, joinKey, joinToValue, len, map, mapPath, ref1, sorted, type, withMaps;
  type = sourceFiles.some(function(file) {
    var ref1;
    return (ref1 = file.type) === 'javascript' || ref1 === 'template';
  }) ? 'javascript' : 'stylesheet';
  optimizers = optimizers.filter(function(optimizer) {
    return optimizer.type === type;
  });
  len = config.paths["public"].length + 1;
  joinKey = path.slice(len);
  joinToValue = config.files[type + "s"].joinTo[joinKey];
  sorted = sort(sourceFiles, config, joinToValue);
  ref1 = concat(sorted, path, type, config._normalized.modules.definition, config._normalized.packageInfo.component.aliases), code = ref1.code, map = ref1.map;
  withMaps = map && config.sourceMaps;
  mapPath = path + ".map";
  return optimize(code, map, path, optimizers, sourceFiles, function(error, data) {
    var controlChar, mapRoute;
    if (error != null) {
      return callback(error);
    }
    if (withMaps) {
      mapRoute = config.sourceMaps === 'absoluteUrl' ? mapPath.replace(config.paths["public"], '').replace('\\', '/') : basename(mapPath);
      controlChar = config.sourceMaps === 'old' ? '@' : '#';
      data.code += type === 'javascript' ? "\n//" + controlChar + " sourceMappingURL=" + mapRoute : "\n/*" + controlChar + " sourceMappingURL=" + mapRoute + "*/";
    }
    return common.writeFile(path, data.code, function() {
      if (withMaps) {
        return common.writeFile(mapPath, data.map.toString(), callback);
      } else {
        return callback();
      }
    });
  });
};

generate.sortByConfig = sortByConfig;

module.exports = generate;
